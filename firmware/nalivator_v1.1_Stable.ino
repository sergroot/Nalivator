
/*  Проект Наливатор.
  Автор Яшкин Сергей (с)2019
  текущая версия software v 1.1 - рабочая, нужно добавить режим энергосбережения
  текущая версия MainBoard_M2 v 1.3
  текущая версия ControlPanel_M3 v 1.2
  текущая версия TensorBoard_M4 v 1.1
  текущая версия LEDPanel_M5 v 1.1
  текущая версия файла с настройками v 1.1
*/

//Подключаем библиотеки
#include "LedControl.h" 							    // Библиотека работы с 7-сегментным индикатором на MAX7219
#include <Encoder.h>   								    // Библиотека работы с энкодером
#include "HX711.h"                        // Работаем с датчиком веса
#include <TimerOne.h>

//Определяем выводы Arduino Mega2560 для подключения периферии
int dataPin = 5;   										    // DOUT для MAX7219
int clkPin = 7;                           // Clock для MAX7219
int csPin = 9; 											      // ChipSelect для MAX7219
int numDevices = 1; 								      // Количество устройств MAX7219. По умолчанию 1, то есть восемь 7-сегментных индикаторов
byte select_but = 3;                      // Pin кнопки энкодера
int pinA = 18;											      // Pin A энекодера. Рекомендуется подключить к выводу Arduino с поддержкой прерывания
int pinB = 20;											      // Pin B энекодера. Рекомендуется подключить к выводу Arduino с поддержкой прерывания
int StartButton = 2;									    // Номер прерывания для кнопки START (pin 21)
int StopButton = 4;									      // Номер прерывания для кнопки STOP (pin 19)
const uint8_t DOUT[4]	= {31, 27, 23, 15};	// Pins выводов DT датчика веса юзеров с 1 до 4-го
const uint8_t CLK [4] = {53, 29, 25, 17}; // Pins выводов SCK датчика веса юзеров с 1 до 4-го
int Red [4] = {46, 40, 34, 66};						// Pins красных светодиодов юзеров от 1 до 4-го
int Green [4] = {44, 38, 32, 64};					// Pins зеленых светодиодов юзеров от 1 до 4-го
int Blue [4] = {42, 36, 68, 62};					// Pins синих светодиодов юзеров от 1 до 4-го
int pump [4] = {47, 48, 50, 52};					// Pins насосов юзеров от 1 до 4-го
float rumka [4];                          // Массив переменных в которых хранится вес рюмок ДО начала налива. будет измеряться перед началом налива в каждую рюмку
int done [4];											        // Признак того, что после нажатия кнопки СТАРТ в указанную тару был налив. Нужен для возможности долива в тару, которую поставили позже. Обнуляются каждый раз после поднятия тары из ячейки
int user_blink = 0;                                             // Номер моргающего юзера. Начальное значение - 0, то есть все горят, не мигая
byte PrevStateSelectButton = 0;                                 // Предыдущее состояние кнопки энкодера: 0 - была отжата, 1 - была нажата
byte payload1 = 25, payload2 = 25, payload3 = 25, payload4 = 25;// Принимаем, что изначально для всех юзеров установлено одинаковое количество граммов - 25
int payload[4] = {payload1, payload2, payload3, payload4};      // Массив для хранения граммов пользователей - запихиваем граммы юзеров в массив
byte minimum = 10;                                              // Меньше 10 грамм налить нельзя... Чего мараться то?
byte maximum = 40;                                              // Больше 40 грамм налить нельзя... Напиваться не стоит, да в и в рюмку не влезет
byte LowLimit = 10;                                             // Минимальный вес тары, ниже которого девайс будет считать, что ничего не установлено и наливать не будем
byte Brutto = 140;                                              // Теоретический максимальный вес тары с продуктом (брутто). Выше этого значения налива не будет ни при каких обстоятельствах
int nalivaem = 0;                                               // Флаг начала налива, устанавливается в 1 по нажатию кнпоки СТАРТ и в 0 по нажатию кнопки СТОП или по окончании налива
boolean EmergencyStop = false;
int nalit_cont = 0;                                             // Устанавливаем в 0, если процесс налива закончен, и в 1 - если идет процесс налива

// Создаем Контрольную Панель
LedControl lc = LedControl(dataPin, clkPin, csPin, numDevices); // Создаем объект lc как экземпляр класса LedControl
Encoder myEnc(pinA, pinB);                                      // Создаем объект myEnc как экземпляр класса Encoder

// Создаем весы
HX711 load_cells[4];                                            // создаём 4 объекта для работы с тензодатчиками
const int   GAIN[4] = {843, 862, 850, 1045};                    // создаём массив с корректирующими коэффициентами для каждого датчика
const int   a[4] = { -72, 119, 186, -124};                      // второй поправочный коэффициент
float loads[4] = {0.0, 0.0, 0.0, 0.0};                          // создаём массив для хранения значений с каждого датчика

// Начальная инициализация и вывод на 7SEG начальных значений
void setup() {
  Serial.begin(9600);                                           // Открываем порт для вывода отладочных сообщений. После дебага можно удалить или закомментить
  Timer1.initialize(350000);                                    // Устанавливаем таймер на 350 мс.
  Timer1.attachInterrupt(check_rumka);                          // Вызываем функцию проверки тары в ячейке с периодичностью строкой выше

  //Определяем типы pins как входы или выходы
  for (int i = 0; i < 4; i++)
  {
    pinMode (DOUT[i], INPUT);
    pinMode (CLK[i], INPUT);
    pinMode (Red[i], OUTPUT);
    pinMode (Green[i], OUTPUT);
    pinMode (Blue[i], OUTPUT);
    pinMode (pump[i], OUTPUT);
  }
  pinMode (StartButton, INPUT);
  pinMode (StopButton, INPUT);

  attachInterrupt(StopButton, STOP, RISING);      // Вызываем функцию STOP немедленно после нажатий кнопки СТОП
  attachInterrupt(StartButton, START, RISING);    // Вызываем функцию START немедленно после нажатия кнопки СТАРТ

  pinMode (select_but, INPUT);					          // Определяем контакт кнопки энкодера как INPUT
  lc.shutdown(0, false);							            // Включаем дисплей
  lc.setIntensity(0, 1);							            // Устанавливаем яркость (0-минимум, 15-максимум)
  lc.clearDisplay(0);								              // Очищаем дисплей

  // Инициализируем весы
  for (int i = 0; i < 4; i++) {                   // выполняем цикл, в котором
    load_cells[i].begin(DOUT[i], CLK[i]);         // выполняем инициализацию 4 тензодатчиков
    load_cells[i].set_scale(GAIN[i]);             // устанавливаем корректирующие коэффициенты для каждого тензодатчика
  }
}


void loop() {
  if (digitalRead(select_but) == HIGH && PrevStateSelectButton == 0)  // Отлавливаем только одно нажатие кнопки энкодера (предыдущее состояние кнопки - отжата), чтобы перейти к следующему юзеру
  { // Если кнопка нажата и ее предыдущее значение - отжата, то ...
    user_blink ++; 													    // ...переходим к следующему юзеру
    if (user_blink == 5) {
      user_blink = 0; // Если предыдущий юзер был 4 (последний), то устанавливаем нулевого юзера, то есть опять не моргаем
    }
    PrevStateSelectButton = 1; 									// Запоминаем, что кнопка была нажата, чтобы не было повторных срабатываний, если удерживать кнопку
  }
  if (digitalRead(select_but) == LOW)						// Переходим к функции моргания только при отпускании кнопки
  {
    PrevStateSelectButton = 0; 								// Опустили кнопку, запоминаем, что кнопка была отжата и теперь ее можно нажать еще раз ...
    LedShow();  												      // ... и пишем в 7LED выбранные значения для всех юзеров и указываем, какой юзер моргает (если 0 - то никакой и экран не моргает)
  }

}

// Подпрограмма мигания выбранным юзером и обработки крутилки энкодера
void LedShow () {
  uint32_t prev_time;                         // Переменная для определения прошедшего с момента последнего моргания на 7SEG индикаторе
  uint32_t prev_change;                       // Переменная для определения задержки моргания после последнего изменения энкодером показаний
  int timing = 400;                           // частота мигания группой индикаторов в милисекундах
  int change_timing = 200;                    // Задержка моргания после последнего изменения энкодером показаний в милисекундах
  int leds[8];                                // Массив чисел, записываемых в 7LED с разбивкой по единицам и десяткам
  int s_blink = 0;                            // Определяем, что выводим на индикатор моргающего юзера: 0 - гасим цифры, 1 - зажигаем его текущее значение, то есть моргаем

  long currentPosition  = payload[user_blink - 1];		// Записываем в текущее значение энкодера граммы текущего юзера ...
  myEnc.write (currentPosition * 4);					        // ... и записываем его в энкодер. Умножаем на 4 потому, что энкодер считает пачками по 4
  //Разделяем единицы и десятки для каждого user и записываем в массив leds
  for (int i = 0; i <= 7; i = i + 2) {
    leds[i] = (payload[i / 2] / 10) % 10;					  // Разделяем десятки ...
    leds[i + 1] = payload[i / 2] % 10;						  // ... и единицы
    lc.setDigit(0, i, (byte)leds[i], false);				 // Отображаем десятки ...
    lc.setDigit(0, i + 1, (byte)leds[i + 1], false); // ... и единицы на 7SEG
  }

  // здесь часть кода, вызываемого, если установлен Флаг nalivaem == 1 и не находимся в процессе налива (nalit_cont == 0). Вызывается функция nalit
  if (nalivaem == 1 and nalit_cont == 0) {
    nalit();
  }

  //Начинаем мигать выбранным юзером - n_blink
  if (user_blink != 0) {
    while (1)										                     // Бесконечный цикл, выход - по нажатию кнопки энкодера (return) или по нажатию кнопок START, STOP  - по прерыванию
    {
      long newPosition = myEnc.read();				          // Читаем текущее положение энекодера и...
      if (newPosition != currentPosition) {		        // Если оно изменилось то...
        if (newPosition / 4 > maximum) { 		          // (Ограничиваем верхний предел...)
          newPosition = maximum * 4; 			            // И умножаем на 4 - энкодер такой...
          myEnc.write (newPosition);
        }
        if (newPosition / 4 < minimum) { 		          // Ограничиваем нижний предел...
          newPosition = minimum * 4; 			             // И умножаем на 4 - энкодер такой...
          myEnc.write (newPosition);
        }
        currentPosition = newPosition;											                    //.. то текущему значению (currentPosition) присваиваем новое значение
        payload[user_blink - 1] = newPosition / 4; 									            // Записываем текущему юзеру накрученное на энкодере значение. Энкодер считает сразу по 4, так что делим 4
        leds[(user_blink - 1) * 2] = (payload[user_blink - 1] / 10) % 10;					 // Сразу же разделяем полученное значение от энкодера на десятки...
        leds[(user_blink - 1) * 2 + 1] = payload[user_blink - 1] % 10; 					 // ... и единицы
        lc.setDigit(0, (byte)(user_blink - 1) * 2, leds[(user_blink - 1) * 2], false); 	 // И тут же пишем цифры в указанные знакоместа для красоты (чтоб без задержек)
        lc.setDigit(0, (byte)(user_blink - 1) * 2 + 1, leds[(user_blink - 1) * 2 + 1], false);	// И тут же пишем цифры в указанные знакоместа для красоты (чтоб без задержек)
        prev_change = millis();
      }

      if (digitalRead(select_but) == HIGH && PrevStateSelectButton == 0) {		  // Отлавливаем нажатие кнопки во всех ветках цикла, так надежнее:)
        return;																	                                // Кнопка нажата - возвращаемся в основной цикл - переходим к следующему юзеру
      }
      if (millis() - prev_time > timing) {										                  // Выжидаем время timing в милисекундах и ...
        prev_time = millis();
        if (s_blink == 0 && millis() - prev_change > change_timing) {			      // Мигаем только в том случае, если с момента последнего изменения на энкодере прошло не меньше change_timing милисекунд
          if (digitalRead(select_but) == HIGH && PrevStateSelectButton == 0) {  // Отлавливаем нажатие кнопки во всех ветках цикла, так надежнее:)
            return;															// Кнопка нажата - возвращаемся в основной цикл - переходим к следующему юзеру
          }
          lc.setDigit(0, (byte)(user_blink - 1) * 2, leds[(user_blink - 1) * 2], false);      // Снова пишем цифры в указанные знакоместа
          lc.setDigit(0, (byte)(user_blink - 1) * 2 + 1, leds[(user_blink - 1) * 2 + 1], false);  // Снова пишем цифры в указанные знакоместа
          s_blink = 1;                                                              // В следующий раз покажем цифры юзера
        } else {
          if (digitalRead(select_but) == HIGH && PrevStateSelectButton == 0) {// Отлавливаем нажатие кнопки во всех ветках цикла, так надежнее:)
            return;																	                          // Кнопка нажата - возвращаемся в основной цикл - переходим к следующему юзеру
          }															                              // В следующий раз гасим цифры юзера
          lc.setChar(0, (user_blink - 1) * 2, (const char)' ', false);           // Пишем в выбранные знакоместа пробелы, то есть гасим знакоместо
          lc.setChar(0, (user_blink - 1) * 2 + 1, (const char)' ', false);         // Пишем в выбранные знакоместа пробелы, то есть гасим знакоместо
          s_blink = 0;                                                            // В следующий раз гасим цифры юзера
        }
      }
    }
  }
}

void STOP() //Останавливаем программу
{
  if ((digitalRead(pump[0]) == HIGH) or (digitalRead(pump[1]) == HIGH) or (digitalRead(pump[2]) == HIGH) or (digitalRead(pump[3]) == HIGH)) {
    nalivaem = 0;
    nalit_cont = 0;
    EmergencyStop = true;
    for (int i = 0; i <= 3; i++)
    {
      digitalWrite(pump[i], LOW);
      if (rumka[i] > LowLimit) {digitalWrite(Red[i], HIGH);}
      digitalWrite(Blue[i], LOW);
      digitalWrite(Green[i], LOW);
      done [i] = 1;
    }
    LedShow();
  }
}

void START() 									          // Ставим флаг, что пора бы и налить...
{
  if (nalit_cont == 0 and digitalRead(Red[0]) == 0 and digitalRead(Red[1]) == 0 and digitalRead(Red[2]) == 0 and digitalRead(Red[3]) == 0) // Разрешаем цикл налива только, если закончен предыдущий и не была активирована экстренная остановка
  {
    user_blink = 0; 								    // Текущий юзер = 0, то есть экран не мигает
    nalivaem = 1; 								      // Возвращаемся в функцию и ждем налива...
    LedShow();
  }
}

float measure(int kranik) 								            // Функция измерения веса. kranik - номер измеряемого веса
{
  loads[kranik] = load_cells[kranik].get_units(), 3;	// считываем значение веса на каждом тензодатчике
  loads[kranik] = loads[kranik] - a[kranik] - 1.5;		// Вычитаем поправочный коэффициент
  return loads[kranik];
}

void nalit () // В эту функцию передается процесс налива в тару. Происходит в два этапа - от первой до четвертой и обратно
{
  nalit_cont = 1;                                     // Сообщаем, что начали цикл налива
  // проверка наличия тары в ячейке
  for (int i = 0; i <= 3; i++) {
    //digitalWrite (Green[i], LOW); // Гасим зеленый
    //digitalWrite (Red[i], LOW);  // Гасим красный
    rumka[i] = measure(i);
    if (rumka[i] > LowLimit && rumka[i] < Brutto && done[i] == 0) {
      Serial.println (done[i]);
      digitalWrite (Blue[i], HIGH); // Если тара есть, то зажигаем синий, иначе гасим его
    } else {
      digitalWrite (Blue[i], LOW);
    }
  }
  // Первый прогон налива от 1 до 4 тары

  for (int i = 0; i <= 3; i++)
  {
    if (done[i] == 0 and measure(i) > LowLimit and rumka[i] < Brutto and digitalRead (Red[i]) == LOW) // Если тара есть и в нее не было налива, то наливаем
    {
      digitalWrite (pump[i], HIGH); // Включаем насос
      while ((measure(i) < (rumka[i] + payload[i])) && measure (i) > LowLimit && measure(i) < Brutto) //Пока измеренный вес меньше веса тары + полезная загрузка и тара присутствует...
      {
        if (measure(i) <= rumka[i] - 5) { // если пользователь убрал тару и передумал наливать, то налив не осуществляем и гасим все светодиоды
          digitalWrite (pump[i], LOW); // Останавливаем насос
          digitalWrite (Blue [i], LOW); // Гасим синий светодиод
          digitalWrite (Green [i], LOW); // Гасим зеленый светодиод
          rumka[i] = 0;
          done[i] = 1;
        }
      }
      // Если загрузка завершена, то...
      digitalWrite (pump[i], LOW); // Останавливаем насос
      digitalWrite (Blue[i], LOW); // Гасим синий светодиод
      if (measure(i) > LowLimit and done[i] == 0) {
        digitalWrite (Green[i], HIGH);// Зажигаем зеленый светодиод
        done[i] = 1;
      }
    }
  }
  nalivaem = 0;                   // Прекращаем налив
  nalit_cont = 0;                 // Разрешаем следующий цикл налива
  user_blink = 0;                 // Устанавливаем флаг в 0, то есть ни один индикатора на ControlPanel не мигает
  LedShow();                      // И идем в начало подпрограммы ожидания нажатий кнопки энкодера для изменения задатчика граммов
}
void check_rumka()                // Проверка наличия тары в ячейке, и если нет, сбрасываем флаг налитой тары (то есть можно наливать снова) и гасим светодиоды под нет
{
  for (int y = 0; y <= 3; y++) {
    if (measure (y) < LowLimit) {   // Если тары нет - ее вес меньше чем LowLimit, то гасим свет
      digitalWrite (Blue[y], LOW);
      digitalWrite (Green[y], LOW);
      digitalWrite (Red[y], LOW);
      done[y] = 0;
    }
  }
}
